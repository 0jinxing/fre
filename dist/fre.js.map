{"version":3,"sources":["dist/fre.js"],"names":["h","type","config","props","key","children","i","arguments","length","vnode","pop","push","nodeValue","arrayfy","arr","Array","isArray","isSame","a","b","isNew","o","n","k","hashfy","out","j","forEach","item","merge","defer","requestAnimationFrame","setTimeout","isFn","fn","updateProperty","dom","name","value","newValue","style","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","updateElement","newProps","Object","keys","filter","createElement","fiber","document","createTextNode","cursor","update","reducer","current","this","getWIP","state","scheduleWork","resetCursor","useState","initState","useReducer","setter","bind","useEffect","cb","inputs","effect","useCallback","useMemo","hasChaged","oldInputs","some","v","isMounted","createContext","init","set","context","subscribe","useContext","ctx","setContext","options","FPS","HOST","HOOK","ROOT","PLACE","UPDATE","DELETE","updateQueue","nextWork","pendingCommit","currentFiber","once","render","el","tag","base","shift","workLoop","startTime","performance","now","nextTime","performWork","commitWork","WIP","updateHOOK","updateHost","child","completeWork","sibling","parent","end","insertPoint","oldPoint","reconcileChildren","patches","fiberize","oldFibers","newFibers","reused","newFiber","oldFiber","patchTag","prevFiber","alternate","createFiber","data","concat","p","commit","removeChild","point","after","nextSibling","firstChild","lastChild","insertBefore","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction h (type, config) {\n  let props = config || {};\n  let key = props.key || null;\n  let children = [];\n\n  for (let i = 2; i < arguments.length; i++) {\n    let vnode = arguments[i];\n    if (vnode === null || vnode === true || vnode === false) ; else if (vnode.pop || typeof vnode === 'object') {\n      children.push(vnode);\n    } else if (typeof vnode === 'function') {\n      children = vnode;\n    } else {\n      children.push({ type: 'text', props: { nodeValue: vnode } });\n    }\n  }\n  props.children = children;\n\n  return { type, props, key }\n}\n\nconst arrayfy = arr => (!arr ? [] : Array.isArray(arr) ? arr : [arr]);\r\n\r\nconst isSame = (a, b) => a.type === b.type;\r\n\r\nconst isNew = (o, n) => k =>\r\n  k !== 'children' && k !== 'key' && o[k] !== n[k];\r\n\r\nfunction hashfy (arr) {\r\n  let out = {};\r\n  let i = 0;\r\n  let j = 0;\r\n  const newKids = arrayfy(arr);\r\n  newKids.forEach(item => {\r\n    if (item.pop) {\r\n      item.forEach(item => {\r\n        let key = ((item || {}).props || {}).key;\r\n        key\r\n          ? (out['.' + i + '.' + key] = item)\r\n          : (out['.' + i + '.' + j] = item) && j++;\r\n      });\r\n      i++;\r\n    } else {\r\n(out['.' + i] = item) && i++;\r\n    }\r\n  });\r\n  return out\r\n}\r\n\r\nfunction merge (a, b) {\r\n  let out = {};\r\n  for (const i in a) out[i] = a[i];\r\n  for (const i in b) out[i] = b[i];\r\n  return out\r\n}\r\nconst defer = requestAnimationFrame || setTimeout;\r\n\r\nconst isFn = fn => typeof fn === 'function';\n\nfunction updateProperty (dom, name, value, newValue) {\n  if (name === 'style') {\n    for (key in newValue) {\n      let style = !newValue || !newValue[key] ? '' : newValue[key];\n      dom[name][key] = style;\n    }\n  } else if (name[0] === 'o' && name[1] === 'n') {\n    name = name.slice(2).toLowerCase();\n    if (value) {\n      dom.removeEventListener(name, value);\n    }\n    dom.addEventListener(name, newValue);\n  } else {\n    dom.setAttribute(name, newValue);\n  }\n}\n\nfunction updateElement (dom, props, newProps) {\n  Object.keys(newProps)\n    .filter(isNew(props, newProps)) // 进行浅比较和过滤\n    .forEach(key => {\n      if (key === 'value' || key === 'nodeValue') {\n        dom[key] = newProps[key];\n      } else {\n        updateProperty(dom, key, props[key], newProps[key]);\n      }\n    });\n}\n\nfunction createElement (fiber) {\n  const dom =\n    fiber.type === 'text'\n      ? document.createTextNode('')\n      : document.createElement(fiber.type);\n  updateElement(dom, [], fiber.props);\n  return dom\n}\n\nlet cursor = 0;\n\nfunction update (key, reducer, value) {\n  const current = this ? this : getWIP();\n  value = reducer ? reducer(current.state[key], value) : value;\n  current.state[key] = value;\n  scheduleWork(current);\n}\nfunction resetCursor () {\n  cursor = 0;\n}\nfunction useState (initState) {\n  return useReducer(null, initState)\n}\nfunction useReducer (reducer, initState) {\n  let current = getWIP();\n  if (!current) return [initState, setter]\n  let key = '$' + cursor;\n  let setter = update.bind(current, key, reducer);\n  cursor++;\n  let state = current.state || {};\n  if (key in state) {\n    return [state[key], setter]\n  } else {\n    current.state[key] = initState;\n    return [initState, setter]\n  }\n}\n\nfunction useEffect (cb, inputs) {\n  let current = getWIP();\n  if (current) current.effect = useCallback(cb, inputs);\n}\n\nfunction useCallback (cb, inputs) {\n  return useMemo(() => cb, inputs)\n}\n\nfunction useMemo (cb, inputs) {\n  let current = getWIP();\n  if (current) {\n    let hasChaged = inputs\n      ? (current.oldInputs || []).some((v, i) => inputs[i] !== v)\n      : true;\n    if (inputs && !inputs.length && !current.isMounted) {\n      hasChaged = true;\n      current.isMounted = true;\n    }\n    current.oldInputs = inputs;\n    \n    if (hasChaged) return cb()\n  }\n}\n\nfunction createContext (init = {}) {\n  let context = init;\n  let set = {};\n  const update = context => {\n    for (let key in set) set[key](context);\n  };\n  const subscribe = (fn, name) => {\n    if (name in set) return\n    set[name] = fn;\n  };\n\n  return { context, update, subscribe, set }\n}\n\nfunction useContext (ctx) {\n  const [context, setContext] = useState(ctx.context);\n  const name = getWIP().type.name;\n  ctx.subscribe(setContext, name);\n  return [context, ctx.update]\n}\n\nconst options = {};\r\nconst FPS = 1000 / 60;\r\nconst [HOST, HOOK, ROOT, PLACE, UPDATE, DELETE] = [0, 1, 2, 3, 4, 5];\r\n\r\nlet updateQueue = [];\r\nlet nextWork = null;\r\nlet pendingCommit = null;\r\nlet currentFiber = null;\r\nlet once = true;\r\n\r\nfunction render (vnode, el) {\r\n  let rootFiber = {\r\n    tag: ROOT,\r\n    base: el,\r\n    props: { children: vnode }\r\n  };\r\n  scheduleWork(rootFiber);\r\n}\r\n\r\nfunction scheduleWork (fiber) {\r\n  updateQueue.push(fiber);\r\n  if (!nextWork) {\r\n    nextWork = updateQueue.shift();\r\n    defer(workLoop);\r\n  }\r\n}\r\n\r\nfunction workLoop (startTime = 0) {\r\n  if (startTime && performance.now() - startTime > FPS) {\r\n    defer(workLoop);\r\n  } else {\r\n    const nextTime = performance.now();\r\n    nextWork = performWork(nextWork);\r\n    if (nextWork) {\r\n      workLoop(nextTime);\r\n    } else {\r\n      options.commitWork\r\n        ? options.commitWork(pendingCommit)\r\n        : commitWork(pendingCommit);\r\n    }\r\n  }\r\n}\r\n\r\nfunction performWork (WIP) {\r\n  WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\r\n  if (WIP.child) return WIP.child\r\n  while (WIP) {\r\n    completeWork(WIP);\r\n    if (WIP.sibling) return WIP.sibling\r\n    WIP = WIP.parent;\r\n  }\r\n}\r\n\r\nfunction updateHost (WIP) {\r\n  if (!options.end && !WIP.base) {\r\n    WIP.base = createElement(WIP);\r\n  }\r\n\r\n  let parent = WIP.parent || {};\r\n  WIP.insertPoint = parent.oldPoint;\r\n  parent.oldPoint = WIP;\r\n  const children = WIP.props.children;\r\n  reconcileChildren(WIP, children);\r\n}\r\n\r\nfunction updateHOOK (WIP) {\r\n  WIP.props = WIP.props || {};\r\n  WIP.state = WIP.state || {};\r\n  currentFiber = WIP;\r\n  resetCursor();\r\n  const children = WIP.type(WIP.props);\r\n  reconcileChildren(WIP, children);\r\n  currentFiber.patches = WIP.patches;\r\n}\r\nfunction fiberize (children, WIP) {\r\n  return (WIP.children = hashfy(children, WIP.children))\r\n}\r\n\r\nfunction reconcileChildren (WIP, children) {\r\n  const oldFibers = WIP.children;\r\n  const newFibers = fiberize(children, WIP);\r\n  let reused = {};\r\n\r\n  for (let k in oldFibers) {\r\n    let newFiber = newFibers[k];\r\n    let oldFiber = oldFibers[k];\r\n\r\n    if (newFiber && isSame(newFiber, oldFiber)) {\r\n      reused[k] = oldFiber;\r\n    } else {\r\n      oldFiber.patchTag = DELETE;\r\n      WIP.patches.push(oldFiber);\r\n    }\r\n  }\r\n\r\n  let prevFiber = null;\r\n  let alternate = null;\r\n\r\n  for (let k in newFibers) {\r\n    let newFiber = newFibers[k];\r\n    let oldFiber = reused[k];\r\n\r\n    // console.log(newFiber,oldFiber)\r\n\r\n    if (oldFiber) {\r\n      alternate = createFiber(oldFiber, {\r\n        patchTag: UPDATE\r\n      });\r\n      if (!options.end) newFiber.patchTag = UPDATE;\r\n      newFiber = merge(alternate, newFiber);\r\n      newFiber.alternate = alternate;\r\n      if (oldFiber.key) {\r\n        newFiber.patchTag = PLACE;\r\n      }\r\n    } else {\r\n      newFiber = createFiber(newFiber, {\r\n        patchTag: PLACE\r\n      });\r\n    }\r\n\r\n    newFibers[k] = newFiber;\r\n    newFiber.parent = WIP;\r\n\r\n    if (prevFiber) {\r\n      prevFiber.sibling = newFiber;\r\n    } else {\r\n      WIP.child = newFiber;\r\n      newFiber.oldPoint = null;\r\n    }\r\n    prevFiber = newFiber;\r\n  }\r\n  if (prevFiber) prevFiber.sibling = null;\r\n}\r\n\r\nfunction createFiber (vnode, data) {\r\n  data.tag = isFn(vnode.type) ? HOOK : HOST;\r\n  vnode.props = vnode.props;\r\n  return merge(vnode, data)\r\n}\r\n\r\nfunction completeWork (fiber) {\r\n  if (!options.end && fiber.parent) {\r\n    fiber.parent.patches = (fiber.parent.patches || []).concat(\r\n      fiber.patches || [],\r\n      fiber.patchTag ? [fiber] : []\r\n    );\r\n  } else {\r\n    pendingCommit = fiber;\r\n  }\r\n}\r\n\r\nfunction commitWork (WIP) {\r\n  WIP.patches.forEach(p => commit(p));\r\n  once = false;\r\n  nextWork = null;\r\n  pendingCommit = null;\r\n}\r\nfunction commit (fiber) {\r\n  let p = fiber.parent;\r\n  while (p.tag == HOOK) p = p.parent;\r\n  const parent = p.base;\r\n  let dom = fiber.base || fiber.child.base;\r\n  p.patches = fiber.patches = [];\r\n  if (fiber.parent.tag == ROOT) return\r\n\r\n  switch (fiber.patchTag) {\r\n    case UPDATE:\r\n      updateElement(dom, fiber.alternate.props, fiber.props);\r\n      break\r\n    case DELETE:\r\n      parent.removeChild(dom);\r\n      break\r\n    default:\r\n      const insertPoint = fiber.insertPoint;\r\n      let point = insertPoint ? insertPoint.base : null;\r\n      let after = point ? point.nextSibling : parent.firstChild;\r\n      if (after == dom) return\r\n      if (after === null && dom === parent.lastChild) return\r\n      if (once) after = null;\r\n      parent.insertBefore(dom, after);\r\n      break\r\n  }\r\n}\r\n\r\nfunction getWIP () {\r\n  return currentFiber || null\r\n}\n\nexports.createContext = createContext;\nexports.createElement = h;\nexports.h = h;\nexports.options = options;\nexports.render = render;\nexports.scheduleWork = scheduleWork;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useEffect = useEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useState = useState;\n//# sourceMappingURL=fre.js.map\n"]}