{"version":3,"sources":["dist/fre.js"],"names":["h","type","config","props","key","children","i","arguments","length","vnode","Array","isArray","push","nodeValue","arrayfy","arr","isSame","a","b","isNew","o","n","k","hashfy","out","j","forEach","item","pop","merge","defer","requestAnimationFrame","setTimeout","isFn","fn","updateProperty","dom","name","value","newValue","style","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","updateElement","newProps","Object","keys","filter","createElement","fiber","document","createTextNode","cursor","update","reducer","current","this","getWIP","state","scheduleWork","resetCursor","useState","initState","useReducer","setter","bind","useEffect","cb","inputs","effect","useCallback","useMemo","isChange","oldInputs","some","v","isMounted","memo","createContext","init","set","context","subscribe","useContext","ctx","setContext","options","FPS","HOST","HOOK","ROOT","PLACE","UPDATE","DELETE","updateQueue","nextWork","pendingCommit","currentFiber","render","el","tag","base","shift","workLoop","startTime","performance","now","nextTime","performWork","commitWork","WIP","updateHOOK","updateHost","child","completeWork","sibling","parent","end","insertPoint","oldPoint","reconcileChildren","patches","fiberize","oldFibers","newFibers","reused","newFiber","oldFiber","patchTag","prevFiber","alternate","createFiber","data","concat","once","p","commit","e","removeChild","point","after","nextSibling","firstChild","lastChild","insertBefore","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction h (type, config) {\n  let props = config || {};\n  let key = props.key || null;\n  let children = [];\n\n  for (let i = 2; i < arguments.length; i++) {\n    let vnode = arguments[i];\n    if (vnode === null || vnode === true || vnode === false) ; else if (Array.isArray(vnode) || typeof vnode === 'object') {\n      children.push(vnode);\n    } else if (typeof vnode === 'function') {\n      children = vnode;\n    } else {\n      children.push({ type: 'text', props: { nodeValue: vnode } });\n    }\n  }\n  props.children = children;\n\n  return { type, props, key }\n}\n\nconst arrayfy = arr => (!arr ? [] : Array.isArray(arr) ? arr : [arr]);\r\n\r\nconst isSame = (a, b) => a.type === b.type;\r\n\r\nconst isNew = (o, n) => k =>\r\n  k !== 'children' && k !== 'key' && o[k] !== n[k];\r\n\r\nfunction hashfy (arr) {\r\n  let out = {};\r\n  let i = 0;\r\n  let j = 0;\r\n  const newKids = arrayfy(arr);\r\n  newKids.forEach(item => {\r\n    if (item.pop) {\r\n      item.forEach(item => {\r\n        let key = ((item || {}).props || {}).key;\r\n        key\r\n          ? (out['.' + i + '.' + key] = item)\r\n          : (out['.' + i + '.' + j] = item) && j++;\r\n      });\r\n      i++;\r\n    } else {\r\n(out['.' + i] = item) && i++;\r\n    }\r\n  });\r\n  return out\r\n}\r\n\r\nfunction merge (a, b) {\r\n  let out = {};\r\n  for (const i in a) out[i] = a[i];\r\n  for (const i in b) out[i] = b[i];\r\n  return out\r\n}\r\nconst defer = requestAnimationFrame || setTimeout;\r\n\r\nconst isFn = fn => typeof fn === 'function';\n\nfunction updateProperty (dom, name, value, newValue) {\n  if (name === 'style') {\n    for (key in newValue) {\n      let style = !newValue || !newValue[key] ? '' : newValue[key];\n      dom[name][key] = style;\n    }\n  } else if (name[0] === 'o' && name[1] === 'n') {\n    name = name.slice(2).toLowerCase();\n    if (value) {\n      dom.removeEventListener(name, value);\n    }\n    dom.addEventListener(name, newValue);\n  } else {\n    dom.setAttribute(name, newValue);\n  }\n}\n\nfunction updateElement (dom, props, newProps) {\n  Object.keys(newProps)\n    .filter(isNew(props, newProps))\n    .forEach(key => {\n      if (key === 'value' || key === 'nodeValue') {\n        dom[key] = newProps[key];\n      } else {\n        updateProperty(dom, key, props[key], newProps[key]);\n      }\n    });\n}\n\nfunction createElement (fiber) {\n  const dom =\n    fiber.type === 'text'\n      ? document.createTextNode('')\n      : document.createElement(fiber.type);\n  updateElement(dom, [], fiber.props);\n  return dom\n}\n\nlet cursor = 0;\n\nfunction update (key, reducer, value) {\n  const current = this ? this : getWIP();\n  value = reducer ? reducer(current.state[key], value) : value;\n  current.state[key] = value;\n  scheduleWork(current);\n}\nfunction resetCursor () {\n  cursor = 0;\n}\nfunction useState (initState) {\n  return useReducer(null, initState)\n}\nfunction useReducer (reducer, initState) {\n  let current = getWIP();\n  if (!current) return [initState, setter]\n  let key = '$' + cursor;\n  let setter = update.bind(current, key, reducer);\n  cursor++;\n  let state = current.state || {};\n  if (key in state) {\n    return [state[key], setter]\n  } else {\n    current.state[key] = initState;\n    return [initState, setter]\n  }\n}\n\nfunction useEffect (cb, inputs) {\n  let current = getWIP();\n  if (current) return\n  let key = '$' + cursor;\n  current.effect = current.effect || {};\n  current.effect[key] = useCallback(cb, inputs);\n  cursor++;\n}\n\nfunction useCallback (cb, inputs) {\n  return useMemo(() => cb, inputs)\n}\n\nfunction useMemo (cb, inputs) {\n  let current = getWIP();\n  if (current) {\n    let isChange = inputs\n      ? (current.oldInputs || []).some((v, i) => inputs[i] !== v)\n      : true;\n    if (inputs && !inputs.length && !current.isMounted) {\n      isChange = true;\n      current.isMounted = true;\n    }\n    current.oldInputs = inputs;\n\n    return isChange || !current.isMounted ? (current.memo = cb()) : current.memo\n  }\n}\n\nfunction createContext (init = {}) {\n  let context = init;\n  let set = {};\n  const update = context => {\n    for (let key in set) set[key](context);\n  };\n  const subscribe = (fn, name) => {\n    if (name in set) return\n    set[name] = fn;\n  };\n\n  return { context, update, subscribe, set }\n}\n\nfunction useContext (ctx) {\n  const [context, setContext] = useState(ctx.context);\n  const name = getWIP().type.name;\n  ctx.subscribe(setContext, name);\n  return [context, ctx.update]\n}\n\nconst options = {};\r\nconst FPS = 1000 / 60;\r\nconst [HOST, HOOK, ROOT, PLACE, UPDATE, DELETE] = [0, 1, 2, 3, 4, 5];\r\n\r\nlet updateQueue = [];\r\nlet nextWork = null;\r\nlet pendingCommit = null;\r\nlet currentFiber = null;\r\n\r\nfunction render (vnode, el) {\r\n  let rootFiber = {\r\n    tag: ROOT,\r\n    base: el,\r\n    props: { children: vnode }\r\n  };\r\n  scheduleWork(rootFiber);\r\n}\r\n\r\nfunction scheduleWork (fiber) {\r\n  updateQueue.push(fiber);\r\n  if (!nextWork) {\r\n    nextWork = updateQueue.shift();\r\n    defer(workLoop);\r\n  }\r\n}\r\n\r\nfunction workLoop (startTime = 0) {\r\n  if (startTime && performance.now() - startTime > FPS) {\r\n    defer(workLoop);\r\n  } else {\r\n    const nextTime = performance.now();\r\n    nextWork = performWork(nextWork);\r\n    if (nextWork) {\r\n      workLoop(nextTime);\r\n    } else {\r\n      options.commitWork\r\n        ? options.commitWork(pendingCommit)\r\n        : commitWork(pendingCommit);\r\n    }\r\n  }\r\n}\r\n\r\nfunction performWork (WIP) {\r\n  WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\r\n  if (WIP.child) return WIP.child\r\n  while (WIP) {\r\n    completeWork(WIP);\r\n    if (WIP.sibling) return WIP.sibling\r\n    WIP = WIP.parent;\r\n  }\r\n}\r\n\r\nfunction updateHost (WIP) {\r\n  if (!options.end && !WIP.base) {\r\n    WIP.base = createElement(WIP);\r\n  }\r\n\r\n  let parent = WIP.parent || {};\r\n  WIP.insertPoint = parent.oldPoint;\r\n  parent.oldPoint = WIP;\r\n  const children = WIP.props.children;\r\n  reconcileChildren(WIP, children);\r\n}\r\n\r\nfunction updateHOOK (WIP) {\r\n  WIP.props = WIP.props || {};\r\n  WIP.state = WIP.state || {};\r\n  currentFiber = WIP;\r\n  resetCursor();\r\n  const children = WIP.type(WIP.props);\r\n  reconcileChildren(WIP, children);\r\n  currentFiber.patches = WIP.patches;\r\n}\r\nfunction fiberize (children, WIP) {\r\n  return (WIP.children = hashfy(children, WIP.children))\r\n}\r\n\r\nfunction reconcileChildren (WIP, children) {\r\n  const oldFibers = WIP.children;\r\n  const newFibers = fiberize(children, WIP);\r\n  let reused = {};\r\n\r\n  for (let k in oldFibers) {\r\n    let newFiber = newFibers[k];\r\n    let oldFiber = oldFibers[k];\r\n\r\n    if (newFiber && isSame(newFiber, oldFiber)) {\r\n      reused[k] = oldFiber;\r\n    } else {\r\n      oldFiber.patchTag = DELETE;\r\n      WIP.patches.push(oldFiber);\r\n    }\r\n  }\r\n\r\n  let prevFiber = null;\r\n  let alternate = null;\r\n\r\n  for (let k in newFibers) {\r\n    let newFiber = newFibers[k];\r\n    let oldFiber = reused[k];\r\n\r\n    if (oldFiber) {\r\n      alternate = createFiber(oldFiber, {\r\n        patchTag: UPDATE\r\n      });\r\n      if (!options.end) newFiber.patchTag = UPDATE;\r\n      newFiber = merge(alternate, newFiber);\r\n      newFiber.alternate = alternate;\r\n      if (oldFiber.key) {\r\n        newFiber.patchTag = PLACE;\r\n      }\r\n    } else {\r\n      newFiber = createFiber(newFiber, {\r\n        patchTag: PLACE\r\n      });\r\n    }\r\n\r\n    newFibers[k] = newFiber;\r\n    newFiber.parent = WIP;\r\n\r\n    if (prevFiber) {\r\n      prevFiber.sibling = newFiber;\r\n    } else {\r\n      WIP.child = newFiber;\r\n      newFiber.oldPoint = null;\r\n    }\r\n    prevFiber = newFiber;\r\n  }\r\n  if (prevFiber) prevFiber.sibling = null;\r\n}\r\n\r\nfunction createFiber (vnode, data) {\r\n  data.tag = isFn(vnode.type) ? HOOK : HOST;\r\n  vnode.props = vnode.props;\r\n  return merge(vnode, data)\r\n}\r\n\r\nfunction completeWork (fiber) {\r\n  if (!options.end && fiber.parent) {\r\n    fiber.parent.patches = (fiber.parent.patches || []).concat(\r\n      fiber.patches || [],\r\n      fiber.patchTag ? [fiber] : []\r\n    );\r\n  } else {\r\n    pendingCommit = fiber;\r\n  }\r\n}\r\n\r\nfunction commitWork (WIP) {\r\n  let once = true;\r\n  WIP.patches.forEach(p => {\r\n    commit(p, once);\r\n    const e = p.effect;\r\n    if (e) {\r\n      for (const k in e) e[k]();\r\n    }\r\n  });\r\n  once = false;\r\n  nextWork = null;\r\n  pendingCommit = null;\r\n}\r\nfunction commit (fiber, once) {\r\n  let p = fiber.parent;\r\n  while (p.tag == HOOK) p = p.parent;\r\n  const parent = p.base;\r\n  let dom = fiber.base || fiber.child.base;\r\n  p.patches = fiber.patches = null;\r\n  if (fiber.parent.tag == ROOT) return\r\n  switch (fiber.patchTag) {\r\n    case UPDATE:\r\n      updateElement(dom, fiber.alternate.props, fiber.props);\r\n      break\r\n    case DELETE:\r\n      parent.removeChild(dom);\r\n      break\r\n    default:\r\n      const insertPoint = fiber.insertPoint;\r\n      let point = insertPoint ? insertPoint.base : null;\r\n      let after = point ? point.nextSibling : parent.firstChild;\r\n      if (after == dom) return\r\n      if (after === null && dom === parent.lastChild) return\r\n      if (once) after = null;\r\n      parent.insertBefore(dom, after);\r\n      break\r\n  }\r\n}\r\n\r\nfunction getWIP () {\r\n  return currentFiber || null\r\n}\n\nexports.createContext = createContext;\nexports.createElement = h;\nexports.h = h;\nexports.options = options;\nexports.render = render;\nexports.scheduleWork = scheduleWork;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useEffect = useEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useState = useState;\n//# sourceMappingURL=fre.js.map\n"]}