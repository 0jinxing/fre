{"version":3,"sources":["dist/fre.js"],"names":["fre","exports","arrayfy","arr","Array","isArray","isSame","a","b","type","isNew","o","n","k","merge","out","i","defer","requestAnimationFrame","setTimeout","h","props","rest","children","length","arguments","push","vnode","pop","nodeValue","key","updateProperty","element","name","value","newValue","style","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","updateElement","newProps","Object","keys","filter","forEach","cursor","update","reducer","current","this","getWIP","state","scheduleWork","useState","initState","useReducer","setter","bind","useCallback","cb","inputs","useMemo","hasChaged","oldInputs","some","v","isMounted","options","FPS","HOST","HOOK","ROOT","PLACE","REPLACE","UPDATE","DELETE","updateQueue","nextWork","pendingCommit","currentFiber","fiber","shift","workLoop","startTime","performance","now","nextTime","WIP","tag","reconcileChildren","patches","updateHOOK","end","base","document","createTextNode","createElement","parent","insertPoint","oldPoint","updateHost","child","completeWork","sibling","performWork","commitWork","p","parentFiber","dom","patchTag","alternate","removeChild","after","nextSibling","firstChild","insertBefore","commit","fiberize","item","hashfy","oldFibers","newFibers","reused","newFiber","oldFiber","prevFiber","createFiber","data","concat","createContext","init","set","context","subscribe","fn","render","el","useContext","ctx","setContext","useEffect","effect"],"mappings":"AAAA,IAAIA,IAAO,SAAUC,GACnB,aAEA,MAAMC,EAAUC,GAASA,EAAWC,MAAMC,QAAQF,GAAOA,EAAM,CAACA,GAAjC,GAEzBG,EAAS,CAACC,EAAGC,IACjBD,EAAEE,OAASD,EAAEC,aAAeF,EAAEE,aAAgBD,EAAEC,KAE5CC,EAAQ,CAACC,EAAGC,IAAMC,GAChB,aAANA,GAA0B,QAANA,GAAeF,EAAEE,KAAOD,EAAEC,GAYhD,SAASC,EAAOP,EAAGC,GACjB,IAAIO,EAAM,GACV,IAAK,IAAIC,KAAKT,EAAGQ,EAAIC,GAAKT,EAAES,GAC5B,IAAK,IAAIA,KAAKR,EAAGO,EAAIC,GAAKR,EAAEQ,GAC5B,OAAOD,EAET,MAAME,EAAQC,uBAAyBC,WAEvC,SAASC,EAAGX,EAAMY,GAChB,IAAIC,EAAO,GACPC,EAAW,GACXC,EAASC,UAAUD,OAEvB,KAAOA,KAAW,GAAGF,EAAKI,KAAKD,UAAUD,IAEzC,KAAOF,EAAKE,QAAQ,CAClB,IAAIG,EAAQL,EAAKM,MACjB,GAAID,GAASA,EAAMC,IACjB,IAAKJ,EAASG,EAAMH,OAAQA,KAAWF,EAAKI,KAAKC,EAAMH,SACpC,OAAVG,IAA4B,IAAVA,IAA4B,IAAVA,EAC7CA,EAAQ,CAAElB,KAAM,QACU,mBAAVkB,EAChBJ,EAAWI,EAEXJ,EAASG,KACU,iBAAVC,EACHA,EACA,CAAElB,KAAM,OAAQY,MAAO,CAAEQ,UAAWF,KAI9C,MAAO,CACLlB,KAAAA,EACAY,MAAOP,EAAMO,EAAO,CAAEE,SAAAA,IACtBO,IAAKT,GAASA,EAAMS,KAIxB,SAASC,EAAgBC,EAASC,EAAMC,EAAOC,GAC7C,GAAa,UAATF,EACF,IAAKH,OAAOK,EAAU,CACpB,IAAIC,EAASD,GAAaA,EAASL,KAAYK,EAASL,KAAd,GAC1CE,EAAQC,GAAMH,KAAOM,MAEF,MAAZH,EAAK,IAA0B,MAAZA,EAAK,IACjCA,EAAOA,EAAKI,MAAM,GAAGC,cACjBJ,GACFF,EAAQO,oBAAoBN,EAAMC,GAEpCF,EAAQQ,iBAAiBP,EAAME,IAE/BH,EAAQS,aAAaR,EAAME,GAI/B,SAASO,EAAeV,EAASX,EAAOsB,GACtCC,OAAOC,KAAKF,GACTG,OAAOpC,EAAMW,EAAOsB,IACpBI,QAAQjB,IACK,UAARA,GAA2B,cAARA,EACrBE,EAAQF,GAAOa,EAASb,GAExBC,EAAeC,EAASF,EAAKT,EAAMS,GAAMa,EAASb,MAc1D,IAAIkB,EAAS,EAEb,SAASC,EAAQnB,EAAKoB,EAAShB,GAC7B,MAAMiB,EAAUC,KAAOA,KAAOC,IAC9BnB,EAAQgB,EAAUA,EAAQC,EAAQG,MAAMxB,GAAMI,GAASA,EACvDiB,EAAQG,MAAMxB,GAAOI,EACrBqB,EAAaJ,GAKf,SAASK,EAAUC,GACjB,OAAOC,EAAW,KAAMD,GAE1B,SAASC,EAAYR,EAASO,GAC5B,IAAIN,EAAUE,IACd,IAAKF,EAAS,MAAO,CAACM,EAAWE,GACjC,IAAI7B,EAAM,IAAMkB,EACZW,EAASV,EAAOW,KAAKT,EAASrB,EAAKoB,GACvCF,IACA,IAAIM,EAAQH,EAAQG,OAAS,GAC7B,OAAIxB,KAAOwB,EACF,CAACA,EAAMxB,GAAM6B,IAEpBR,EAAQG,MAAMxB,GAAO2B,EACd,CAACA,EAAWE,IASvB,SAASE,EAAaC,EAAIC,GACxB,OAAOC,EAAQ,IAAMF,EAAIC,GAG3B,SAASC,EAASF,EAAIC,GACpB,IAAIZ,EAAUE,IACd,GAAIF,EAAS,CACX,IAAIc,GAAYF,IACXZ,EAAQe,WAAa,IAAIC,KAAK,CAACC,EAAGpD,IAAM+C,EAAO/C,KAAOoD,GAQ3D,IANIL,GAAWA,EAAOvC,QAAW2B,EAAQkB,YACvCJ,GAAY,EACZd,EAAQkB,WAAY,GAEtBlB,EAAQe,UAAYH,EAEhBE,EAAW,OAAOH,KAyB1B,MAAMQ,EAAU,GACVC,EAAM,IAAO,IACZC,EAAMC,EAAMC,EAAMC,EAAOC,EAASC,EAAQC,GAAU,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAE9E,IAAIC,EAAc,GACdC,EAAW,KACXC,EAAgB,KAChBC,EAAe,KAWnB,SAAS3B,EAAc4B,GACrBJ,EAAYrD,KAAKyD,GACZH,IACHA,EAAWD,EAAYK,QACvBnE,EAAMoE,IAIV,SAASA,EAAUC,EAAY,GAC7B,GAAIA,GAAaC,YAAYC,MAAQF,EAAYf,EAC/CtD,EAAMoE,OACD,CACL,MAAMI,EAAWF,YAAYC,OAC7BR,EAWJ,SAAsBU,GAEpB,GADAA,EAAIC,KAAOlB,EAsBb,SAAqBiB,GACnBA,EAAIrE,MAAQqE,EAAIrE,OAAS,GACzBqE,EAAIpC,MAAQoC,EAAIpC,OAAS,GACzB4B,EAAeQ,EAtIf1C,EAAS,EAwIT,MAAMzB,EAAWmE,EAAIjF,KAAKiF,EAAIrE,OAC9BuE,EAAkBF,EAAKnE,GACvB2D,EAAaW,QAAUH,EAAIG,QA7BTC,CAAWJ,GAS/B,SAAqBA,GACdpB,EAAQyB,KAAQL,EAAIM,OACvBN,EAAIM,KA1IR,SAAwBb,GACtB,MAAMnD,EACW,SAAfmD,EAAM1E,KACFwF,SAASC,eAAe,IACxBD,SAASE,cAAchB,EAAM1E,MAEnC,OADAiC,EAAcV,EAAS,GAAImD,EAAM9D,OAC1BW,EAoIMmE,CAAcT,IAG3B,IAAIU,EAASV,EAAIU,QAAU,GAC3BV,EAAIW,YAAcD,EAAOE,SACzBF,EAAOE,SAAWZ,EAElB,MAAMnE,EAAWmE,EAAIrE,MAAME,SAC3BqE,EAAkBF,EAAKnE,GAnBagF,CAAWb,GAC3CA,EAAIc,MAAO,OAAOd,EAAIc,MAC1B,KAAOd,GAAK,CAEV,GADAe,EAAaf,GACTA,EAAIgB,QAAS,OAAOhB,EAAIgB,QAC5BhB,EAAMA,EAAIU,QAjBCO,CAAY3B,IAErBK,EAASI,GAETnB,EAAQsC,WACJtC,EAAQsC,WAAW3B,IACRA,EAiHfY,QAAQ9C,QAAQ8D,IAItB,SAAiB1B,GACf,IAAI2B,EAAc3B,EAAMiB,OACxB,KAAOU,EAAYnB,KAAOlB,GACxBqC,EAAcA,EAAYV,OAE5B,MAAMA,EAASU,EAAYd,KAC3B,IAAIe,EAAM5B,EAAMa,MAAQb,EAAMqB,MAAMR,KACpC,MAAMK,YAAEA,EAAWW,SAAEA,GAAa7B,EAClC,GAAIA,EAAMiB,OAAOT,KAAOjB,QAAa,GAAIsC,GAAYnC,EACnDnC,EAAcqE,EAAK5B,EAAM8B,UAAU5F,MAAO8D,EAAM9D,YAC3C,GAAI2F,GAAYlC,EACrBsB,EAAOc,YAAYH,OACd,CACL,IAAII,EAAQd,EACRW,GAAYrC,EACV0B,EAAYL,KAAKoB,YACjBf,EAAYL,KAAKoB,aAAehB,EAAOiB,WACzC,KACJ,GAAIF,GAASJ,EAAK,OAClBX,EAAOkB,aAAaP,EAAKI,GAE3BL,EAAYjB,QAAUV,EAAMU,QAAU,IAzBb0B,CAAOV,IAChC7B,EAAWC,EAAgB,OA7E7B,SAASuC,EAAUjG,EAAUmE,GAC3B,OAAQA,EAAInE,SA5Od,SAAiBpB,GACf,IAAIY,EAAM,GACNC,EAAI,EAKR,OAJAd,EAAQC,GAAK4C,QAAQ0E,IACnB,IAAI3F,IAAQ2F,GAAQ,IAAIpG,OAAS,IAAIS,IACrCA,EAAOf,EAAI,IAAMe,GAAO2F,GAAS1G,EAAI,IAAMC,GAAKyG,IAASzG,MAEpDD,EAqOgB2G,CAAOnG,GAGhC,SAASqE,EAAmBF,EAAKnE,GAC/B,MAAMoG,EAAYjC,EAAInE,SAChBqG,EAAYJ,EAASjG,EAAUmE,GACrC,IAAImC,EAAS,GAEb,IAAK,IAAIhH,KAAK8G,EAAW,CACvB,IAAIG,EAAWF,EAAU/G,GACrBkH,EAAWJ,EAAU9G,GACrBiH,GAAYxH,EAAOwH,EAAUC,GAC/BF,EAAOhH,GAAKkH,GAEZA,EAASf,SAAWlC,EACpBY,EAAIG,QAAQnE,KAAKqG,IAIrB,IAAIC,EAAY,KACZf,EAAY,KAEhB,IAAK,IAAIpG,KAAK+G,EAAW,CACvB,IAAIE,EAAWF,EAAU/G,GACrBkH,EAAWF,EAAOhH,GAElBkH,EACEzH,EAAOyH,EAAUD,KACnBb,EAAYgB,EAAYF,EAAU,CAChCf,SAAUnC,IAGPP,EAAQyB,MAAK+B,EAASd,SAAWnC,IACtCiD,EAAWhH,EAAMmG,EAAWa,IACnBb,UAAYA,EACjBc,EAASjG,MACXgG,EAASd,SAAWpC,IAIxBkD,EAAWG,EAAYH,EAAU,CAC/Bd,SAAUrC,IAGdiD,EAAU/G,GAAKiH,EACfA,EAAS1B,OAASV,EAEdsC,EACFA,EAAUtB,QAAUoB,EAEpBpC,EAAIc,MAAQsB,EAEdE,EAAYF,EAEVE,IAAWA,EAAUtB,QAAU,MAGrC,SAASuB,EAAatG,EAAOuG,GAG3B,OAFAA,EAAKvC,IAA4B,mBAAfhE,EAAMlB,KAAsBgE,EAAOD,EACrD7C,EAAMN,MAAQM,EAAMN,OAAS,CAAEQ,UAAWF,EAAME,WACzCf,EAAMa,EAAOuG,GAGtB,SAASzB,EAActB,IAChBb,EAAQyB,KAAOZ,EAAMiB,OACxBjB,EAAMiB,OAAOP,SAAWV,EAAMiB,OAAOP,SAAW,IAAIsC,OAClDhD,EAAMU,SAAW,GACjBV,EAAM6B,SAAW,CAAC7B,GAAS,IAG7BF,EAAgBE,EAiCpB,SAAS9B,IACP,OAAO6B,GAAgB,KAgBzB,OAbAjF,EAAQmI,cA3MR,SAAwBC,EAAO,IAC7B,IACIC,EAAM,GASV,MAAO,CAAEC,QAVKF,EAUIpF,OARHsF,IACb,IAAK,IAAIzG,KAAOwG,EAAKA,EAAIxG,GAAKyG,IAONC,UALR,CAACC,EAAIxG,KACjBA,KAAQqG,IACZA,EAAIrG,GAAQwG,IAGuBH,IAAAA,IAiMvCrI,EAAQkG,cAAgB/E,EACxBnB,EAAQmB,EAAIA,EACZnB,EAAQqE,QAAUA,EAClBrE,EAAQyI,OAjLR,SAAiB/G,EAAOgH,GAMtBpF,EALgB,CACdoC,IAAKjB,EACLsB,KAAM2C,EACNtH,MAAO,CAAEE,SAAUI,MA8KvB1B,EAAQsD,aAAeA,EACvBtD,EAAQ4D,YAAcA,EACtB5D,EAAQ2I,WApMR,SAAqBC,GACnB,MAAON,EAASO,GAActF,EAASqF,EAAIN,SACrCtG,EAAOoB,IAAS5C,KAAKwB,KAE3B,OADA4G,EAAIL,UAAUM,EAAY7G,GACnB,CAACsG,EAASM,EAAI5F,SAiMvBhD,EAAQ8I,UA5OR,SAAoBjF,EAAIC,GACtB,IAAIZ,EAAUE,IACVF,IAASA,EAAQ6F,OAASnF,EAAYC,EAAIC,KA2OhD9D,EAAQ+D,QAAUA,EAClB/D,EAAQyD,WAAaA,EACrBzD,EAAQuD,SAAWA,EAEZvD,EA/WC,CAiXR","sourcesContent":["var fre = (function (exports) {\n  'use strict';\n\n  const arrayfy = arr => (!arr ? [] : Array.isArray(arr) ? arr : [arr]);\r\n\r\n  const isSame = (a, b) =>\r\n    a.type === b.type || typeof a.type === typeof b.type;\r\n\r\n  const isNew = (o, n) => k =>\r\n    k !== 'children' && k !== 'key' && o[k] !== n[k];\r\n\r\n  function hashfy (arr) {\r\n    let out = {};\r\n    let i = 0;\r\n    arrayfy(arr).forEach(item => {\r\n      let key = ((item || {}).props || {}).key;\r\n      key ? (out['.' + key] = item) : (out['.' + i] = item) && i++;\r\n    });\r\n    return out\r\n  }\r\n\r\n  function merge (a, b) {\r\n    let out = {};\r\n    for (var i in a) out[i] = a[i];\r\n    for (var i in b) out[i] = b[i];\r\n    return out\r\n  }\r\n  const defer = requestAnimationFrame || setTimeout;\n\n  function h (type, props) {\n    let rest = [];\n    let children = [];\n    let length = arguments.length;\n\n    while (length-- > 2) rest.push(arguments[length]);\n\n    while (rest.length) {\n      let vnode = rest.pop();\n      if (vnode && vnode.pop) {\n        for (length = vnode.length; length--;) rest.push(vnode[length]);\n      } else if (vnode === null || vnode === true || vnode === false) {\n        vnode = { type: () => {} };\n      } else if (typeof vnode === 'function') {\n        children = vnode;\n      } else {\n        children.push(\n          typeof vnode === 'object'\n            ? vnode\n            : { type: 'text', props: { nodeValue: vnode } }\n        );\n      }\n    }\n    return {\n      type,\n      props: merge(props, { children }),\n      key: props && props.key\n    }\n  }\n\n  function updateProperty (element, name, value, newValue) {\n    if (name === 'style') {\n      for (key in newValue) {\n        let style = !newValue || !newValue[key] ? '' : newValue[key];\n        element[name][key] = style;\n      }\n    } else if (name[0] === 'o' && name[1] === 'n') {\n      name = name.slice(2).toLowerCase();\n      if (value) {\n        element.removeEventListener(name, value);\n      }\n      element.addEventListener(name, newValue);\n    } else {\n      element.setAttribute(name, newValue);\n    }\n  }\n\n  function updateElement (element, props, newProps) {\n    Object.keys(newProps)\n      .filter(isNew(props, newProps)) //进行浅比较和过滤\n      .forEach(key => {\n        if (key === 'value' || key === 'nodeValue') {\n          element[key] = newProps[key];\n        } else {\n          updateProperty(element, key, props[key], newProps[key]);\n        }\n      });\n  }\n\n  function createElement (fiber) {\n    const element =\n      fiber.type === 'text'\n        ? document.createTextNode('')\n        : document.createElement(fiber.type);\n    updateElement(element, [], fiber.props);\n    return element\n  }\n\n  let cursor = 0;\n\n  function update (key, reducer, value) {\n    const current = this ? this : getWIP();\n    value = reducer ? reducer(current.state[key], value) : value;\n    current.state[key] = value;\n    scheduleWork(current);\n  }\n  function resetCursor () {\n    cursor = 0;\n  }\n  function useState (initState) {\n    return useReducer(null, initState)\n  }\n  function useReducer (reducer, initState) {\n    let current = getWIP();\n    if (!current) return [initState, setter]\n    let key = '$' + cursor;\n    let setter = update.bind(current, key, reducer);\n    cursor++;\n    let state = current.state || {};\n    if (key in state) {\n      return [state[key], setter]\n    } else {\n      current.state[key] = initState;\n      return [initState, setter]\n    }\n  }\n\n  function useEffect (cb, inputs) {\n    let current = getWIP();\n    if (current) current.effect = useCallback(cb, inputs);\n  }\n\n  function useCallback (cb, inputs) {\n    return useMemo(() => cb, inputs)\n  }\n\n  function useMemo (cb, inputs) {\n    let current = getWIP();\n    if (current) {\n      let hasChaged = inputs\n        ? (current.oldInputs || []).some((v, i) => inputs[i] !== v)\n        : true;\n      if (inputs && !inputs.length && !current.isMounted) {\n        hasChaged = true;\n        current.isMounted = true;\n      }\n      current.oldInputs = inputs;\n      \n      if (hasChaged) return cb()\n    }\n  }\n\n  function createContext (init = {}) {\n    let context = init;\n    let set = {};\n    const update = context => {\n      for (let key in set) set[key](context);\n    };\n    const subscribe = (fn, name) => {\n      if (name in set) return\n      set[name] = fn;\n    };\n\n    return { context, update, subscribe, set }\n  }\n\n  function useContext (ctx) {\n    const [context, setContext] = useState(ctx.context);\n    const name = getWIP().type.name;\n    ctx.subscribe(setContext, name);\n    return [context, ctx.update]\n  }\n\n  const options = {};\r\n  const FPS = 1000 / 60;\r\n  const [HOST, HOOK, ROOT, PLACE, REPLACE, UPDATE, DELETE] = [0, 1, 2, 3, 4, 5, 6];\r\n\r\n  let updateQueue = [];\r\n  let nextWork = null;\r\n  let pendingCommit = null;\r\n  let currentFiber = null;\r\n\r\n  function render (vnode, el) {\r\n    let rootFiber = {\r\n      tag: ROOT,\r\n      base: el,\r\n      props: { children: vnode }\r\n    };\r\n    scheduleWork(rootFiber);\r\n  }\r\n\r\n  function scheduleWork (fiber) {\r\n    updateQueue.push(fiber);\r\n    if (!nextWork) {\r\n      nextWork = updateQueue.shift();\r\n      defer(workLoop);\r\n    }\r\n  }\r\n\r\n  function workLoop (startTime = 0) {\r\n    if (startTime && performance.now() - startTime > FPS) {\r\n      defer(workLoop);\r\n    } else {\r\n      const nextTime = performance.now();\r\n      nextWork = performWork(nextWork);\r\n      if (nextWork) {\r\n        workLoop(nextTime);\r\n      } else {\r\n        options.commitWork\r\n          ? options.commitWork(pendingCommit)\r\n          : commitWork(pendingCommit);\r\n      }\r\n    }\r\n  }\r\n\r\n  function performWork (WIP) {\r\n    WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\r\n    if (WIP.child) return WIP.child\r\n    while (WIP) {\r\n      completeWork(WIP);\r\n      if (WIP.sibling) return WIP.sibling\r\n      WIP = WIP.parent;\r\n    }\r\n  }\r\n\r\n  function updateHost (WIP) {\r\n    if (!options.end && !WIP.base) {\r\n      WIP.base = createElement(WIP);\r\n    }\r\n\r\n    let parent = WIP.parent || {};\r\n    WIP.insertPoint = parent.oldPoint;\r\n    parent.oldPoint = WIP;\r\n\r\n    const children = WIP.props.children;\r\n    reconcileChildren(WIP, children);\r\n  }\r\n\r\n  function updateHOOK (WIP) {\r\n    WIP.props = WIP.props || {};\r\n    WIP.state = WIP.state || {};\r\n    currentFiber = WIP;\r\n    resetCursor();\r\n    const children = WIP.type(WIP.props);\r\n    reconcileChildren(WIP, children);\r\n    currentFiber.patches = WIP.patches;\r\n  }\r\n  function fiberize (children, WIP) {\r\n    return (WIP.children = hashfy(children))\r\n  }\r\n\r\n  function reconcileChildren (WIP, children) {\r\n    const oldFibers = WIP.children;\r\n    const newFibers = fiberize(children, WIP);\r\n    let reused = {};\r\n\r\n    for (let k in oldFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = oldFibers[k];\r\n      if (newFiber && isSame(newFiber, oldFiber)) {\r\n        reused[k] = oldFiber;\r\n      } else {\r\n        oldFiber.patchTag = DELETE;\r\n        WIP.patches.push(oldFiber);\r\n      }\r\n    }\r\n\r\n    let prevFiber = null;\r\n    let alternate = null;\r\n\r\n    for (let k in newFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = reused[k];\r\n\r\n      if (oldFiber) {\r\n        if (isSame(oldFiber, newFiber)) {\r\n          alternate = createFiber(oldFiber, {\r\n            patchTag: UPDATE\r\n          });\r\n\r\n          if (!options.end) newFiber.patchTag = UPDATE;\r\n          newFiber = merge(alternate, newFiber);\r\n          newFiber.alternate = alternate;\r\n          if (oldFiber.key) {\r\n            newFiber.patchTag = REPLACE;\r\n          }\r\n        }\r\n      } else {\r\n        newFiber = createFiber(newFiber, {\r\n          patchTag: PLACE\r\n        });\r\n      }\r\n      newFibers[k] = newFiber;\r\n      newFiber.parent = WIP;\r\n\r\n      if (prevFiber) {\r\n        prevFiber.sibling = newFiber;\r\n      } else {\r\n        WIP.child = newFiber;\r\n      }\r\n      prevFiber = newFiber;\r\n    }\r\n    if (prevFiber) prevFiber.sibling = null;\r\n  }\r\n\r\n  function createFiber (vnode, data) {\r\n    data.tag = typeof vnode.type === 'function' ? HOOK : HOST;\r\n    vnode.props = vnode.props || { nodeValue: vnode.nodeValue };\r\n    return merge(vnode, data)\r\n  }\r\n\r\n  function completeWork (fiber) {\r\n    if (!options.end && fiber.parent) {\r\n      fiber.parent.patches = (fiber.parent.patches || []).concat(\r\n        fiber.patches || [],\r\n        fiber.patchTag ? [fiber] : []\r\n      );\r\n    } else {\r\n      pendingCommit = fiber;\r\n    }\r\n  }\r\n\r\n  function commitWork (WIP) {\r\n    WIP.patches.forEach(p => commit(p));\r\n    nextWork = pendingCommit = null;\r\n  }\r\n\r\n  function commit (fiber) {\r\n    let parentFiber = fiber.parent;\r\n    while (parentFiber.tag == HOOK) {\r\n      parentFiber = parentFiber.parent;\r\n    }\r\n    const parent = parentFiber.base;\r\n    let dom = fiber.base || fiber.child.base;\r\n    const { insertPoint, patchTag } = fiber;\r\n    if (fiber.parent.tag == ROOT) ; else if (patchTag == UPDATE) {\r\n      updateElement(dom, fiber.alternate.props, fiber.props);\r\n    } else if (patchTag == DELETE) {\r\n      parent.removeChild(dom);\r\n    } else {\r\n      let after = insertPoint\r\n        ? patchTag == PLACE\r\n          ? insertPoint.base.nextSibling\r\n          : insertPoint.base.nextSibling || parent.firstChild\r\n        : null;\r\n      if (after == dom) return\r\n      parent.insertBefore(dom, after);\r\n    }\r\n    parentFiber.patches = fiber.patches = [];\r\n  }\r\n\r\n  function getWIP () {\r\n    return currentFiber || null\r\n  }\n\n  exports.createContext = createContext;\n  exports.createElement = h;\n  exports.h = h;\n  exports.options = options;\n  exports.render = render;\n  exports.scheduleWork = scheduleWork;\n  exports.useCallback = useCallback;\n  exports.useContext = useContext;\n  exports.useEffect = useEffect;\n  exports.useMemo = useMemo;\n  exports.useReducer = useReducer;\n  exports.useState = useState;\n\n  return exports;\n\n}({}));\n//# sourceMappingURL=fre.js.map\n"]}