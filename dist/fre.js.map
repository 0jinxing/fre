{"version":3,"sources":["dist/fre.js"],"names":["fre","exports","h","type","config","props","key","children","i","arguments","length","vnode","pop","push","nodeValue","arrayfy","arr","Array","isArray","isSame","a","b","isNew","o","n","k","merge","out","defer","requestAnimationFrame","setTimeout","isFn","fn","updateProperty","element","name","value","newValue","style","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","updateElement","newProps","Object","keys","filter","forEach","cursor","update","reducer","current","this","getWIP","state","scheduleWork","useState","initState","useReducer","setter","bind","useCallback","cb","inputs","useMemo","hasChaged","oldInputs","some","v","isMounted","options","FPS","HOST","HOOK","ROOT","PLACE","UPDATE","DELETE","updateQueue","nextWork","pendingCommit","currentFiber","once","fiber","shift","workLoop","startTime","performance","now","nextTime","WIP","tag","reconcileChildren","patches","updateHOOK","end","base","document","createTextNode","createElement","parent","insertPoint","oldPoint","updateHost","child","completeWork","sibling","performWork","commitWork","p","dom","patchTag","alternate","removeChild","point","after","nextSibling","firstChild","lastChild","insertBefore","commit","fiberize","j","item","hashfy","oldFibers","newFibers","reused","newFiber","oldFiber","prevFiber","createFiber","data","concat","createContext","init","set","context","subscribe","render","el","useContext","ctx","setContext","useEffect","effect"],"mappings":"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","sourcesContent":["var fre = (function (exports) {\n  'use strict';\n\n  function h (type, config) {\n    let props = config || {};\n    let key = props.key || null;\n    let children = [];\n\n    for (let i = 2; i < arguments.length; i++) {\n      let vnode = arguments[i];\n      if (vnode === null || vnode === true || vnode === false) ; else if (vnode.pop || typeof vnode === 'object') {\n        children.push(vnode);\n      } else if (typeof vnode === 'function') {\n        children = vnode;\n      } else {\n        children.push({ type: 'text', props: { nodeValue: vnode } });\n      }\n    }\n    props.children = children;\n\n    return { type, props, key }\n  }\n\n  const arrayfy = arr => (!arr ? [] : Array.isArray(arr) ? arr : [arr]);\r\n\r\n  const isSame = (a, b) => a.type === b.type;\r\n\r\n  const isNew = (o, n) => k =>\r\n    k !== 'children' && k !== 'key' && o[k] !== n[k];\r\n\r\n  function hashfy (arr) {\r\n    let out = {};\r\n    let i = 0;\r\n    let j = 0;\r\n    const newKids = arrayfy(arr);\r\n    newKids.forEach(item => {\r\n      if (item.pop) {\r\n        item.forEach(item => {\r\n          let key = ((item || {}).props || {}).key;\r\n          key\r\n            ? (out['.' + i + '.' + key] = item)\r\n            : (out['.' + i + '.' + j] = item) && j++;\r\n        });\r\n        i++;\r\n      } else {\r\n  (out['.' + i] = item) && i++;\r\n      }\r\n    });\r\n    return out\r\n  }\r\n\r\n  function merge (a, b) {\r\n    let out = {};\r\n    for (const i in a) out[i] = a[i];\r\n    for (const i in b) out[i] = b[i];\r\n    return out\r\n  }\r\n  const defer = requestAnimationFrame || setTimeout;\r\n\r\n  const isFn = fn => typeof fn === 'function';\n\n  function updateProperty (element, name, value, newValue) {\n    if (name === 'style') {\n      for (key in newValue) {\n        let style = !newValue || !newValue[key] ? '' : newValue[key];\n        element[name][key] = style;\n      }\n    } else if (name[0] === 'o' && name[1] === 'n') {\n      name = name.slice(2).toLowerCase();\n      if (value) {\n        element.removeEventListener(name, value);\n      }\n      element.addEventListener(name, newValue);\n    } else {\n      element.setAttribute(name, newValue);\n    }\n  }\n\n  function updateElement (element, props, newProps) {\n    Object.keys(newProps)\n      .filter(isNew(props, newProps)) //进行浅比较和过滤\n      .forEach(key => {\n        if (key === 'value' || key === 'nodeValue') {\n          element[key] = newProps[key];\n        } else {\n          updateProperty(element, key, props[key], newProps[key]);\n        }\n      });\n  }\n\n  function createElement (fiber) {\n    const element =\n      fiber.type === 'text'\n        ? document.createTextNode('')\n        : document.createElement(fiber.type);\n    updateElement(element, [], fiber.props);\n    return element\n  }\n\n  let cursor = 0;\n\n  function update (key, reducer, value) {\n    const current = this ? this : getWIP();\n    value = reducer ? reducer(current.state[key], value) : value;\n    current.state[key] = value;\n    scheduleWork(current);\n  }\n  function resetCursor () {\n    cursor = 0;\n  }\n  function useState (initState) {\n    return useReducer(null, initState)\n  }\n  function useReducer (reducer, initState) {\n    let current = getWIP();\n    if (!current) return [initState, setter]\n    let key = '$' + cursor;\n    let setter = update.bind(current, key, reducer);\n    cursor++;\n    let state = current.state || {};\n    if (key in state) {\n      return [state[key], setter]\n    } else {\n      current.state[key] = initState;\n      return [initState, setter]\n    }\n  }\n\n  function useEffect (cb, inputs) {\n    let current = getWIP();\n    if (current) current.effect = useCallback(cb, inputs);\n  }\n\n  function useCallback (cb, inputs) {\n    return useMemo(() => cb, inputs)\n  }\n\n  function useMemo (cb, inputs) {\n    let current = getWIP();\n    if (current) {\n      let hasChaged = inputs\n        ? (current.oldInputs || []).some((v, i) => inputs[i] !== v)\n        : true;\n      if (inputs && !inputs.length && !current.isMounted) {\n        hasChaged = true;\n        current.isMounted = true;\n      }\n      current.oldInputs = inputs;\n      \n      if (hasChaged) return cb()\n    }\n  }\n\n  function createContext (init = {}) {\n    let context = init;\n    let set = {};\n    const update = context => {\n      for (let key in set) set[key](context);\n    };\n    const subscribe = (fn, name) => {\n      if (name in set) return\n      set[name] = fn;\n    };\n\n    return { context, update, subscribe, set }\n  }\n\n  function useContext (ctx) {\n    const [context, setContext] = useState(ctx.context);\n    const name = getWIP().type.name;\n    ctx.subscribe(setContext, name);\n    return [context, ctx.update]\n  }\n\n  const options = {};\r\n  const FPS = 1000 / 60;\r\n  const [HOST, HOOK, ROOT, PLACE, UPDATE, DELETE] = [0, 1, 2, 3, 4, 5];\r\n\r\n  let updateQueue = [];\r\n  let nextWork = null;\r\n  let pendingCommit = null;\r\n  let currentFiber = null;\r\n  let once = true;\r\n\r\n  function render (vnode, el) {\r\n    let rootFiber = {\r\n      tag: ROOT,\r\n      base: el,\r\n      props: { children: vnode }\r\n    };\r\n    scheduleWork(rootFiber);\r\n  }\r\n\r\n  function scheduleWork (fiber) {\r\n    updateQueue.push(fiber);\r\n    if (!nextWork) {\r\n      nextWork = updateQueue.shift();\r\n      defer(workLoop);\r\n    }\r\n  }\r\n\r\n  function workLoop (startTime = 0) {\r\n    if (startTime && performance.now() - startTime > FPS) {\r\n      defer(workLoop);\r\n    } else {\r\n      const nextTime = performance.now();\r\n      nextWork = performWork(nextWork);\r\n      if (nextWork) {\r\n        workLoop(nextTime);\r\n      } else {\r\n        options.commitWork\r\n          ? options.commitWork(pendingCommit)\r\n          : commitWork(pendingCommit);\r\n      }\r\n    }\r\n  }\r\n\r\n  function performWork (WIP) {\r\n    WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\r\n    if (WIP.child) return WIP.child\r\n    while (WIP) {\r\n      completeWork(WIP);\r\n      if (WIP.sibling) return WIP.sibling\r\n      WIP = WIP.parent;\r\n    }\r\n  }\r\n\r\n  function updateHost (WIP) {\r\n    if (!options.end && !WIP.base) {\r\n      WIP.base = createElement(WIP);\r\n    }\r\n\r\n    let parent = WIP.parent || {};\r\n    WIP.insertPoint = parent.oldPoint;\r\n    parent.oldPoint = WIP;\r\n    const children = WIP.props.children;\r\n    reconcileChildren(WIP, children);\r\n  }\r\n\r\n  function updateHOOK (WIP) {\r\n    WIP.props = WIP.props || {};\r\n    WIP.state = WIP.state || {};\r\n    currentFiber = WIP;\r\n    resetCursor();\r\n    const children = WIP.type(WIP.props);\r\n    reconcileChildren(WIP, children);\r\n    currentFiber.patches = WIP.patches;\r\n  }\r\n  function fiberize (children, WIP) {\r\n    return (WIP.children = hashfy(children, WIP.children))\r\n  }\r\n\r\n  function reconcileChildren (WIP, children) {\r\n    const oldFibers = WIP.children;\r\n    const newFibers = fiberize(children, WIP);\r\n    let reused = {};\r\n\r\n    for (let k in oldFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = oldFibers[k];\r\n\r\n      if (newFiber && isSame(newFiber, oldFiber)) {\r\n        reused[k] = oldFiber;\r\n      } else {\r\n        oldFiber.patchTag = DELETE;\r\n        WIP.patches.push(oldFiber);\r\n      }\r\n    }\r\n\r\n    let prevFiber = null;\r\n    let alternate = null;\r\n\r\n    for (let k in newFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = reused[k];\r\n\r\n      if (oldFiber) {\r\n        alternate = createFiber(oldFiber, {\r\n          patchTag: UPDATE\r\n        });\r\n        if (!options.end) newFiber.patchTag = UPDATE;\r\n        newFiber = merge(alternate, newFiber);\r\n        newFiber.alternate = alternate;\r\n        if (oldFiber.key) {\r\n          newFiber.patchTag = PLACE;\r\n        }\r\n      } else {\r\n        newFiber = createFiber(newFiber, {\r\n          patchTag: PLACE\r\n        });\r\n      }\r\n\r\n      newFibers[k] = newFiber;\r\n      newFiber.parent = WIP;\r\n\r\n      if (prevFiber) {\r\n        prevFiber.sibling = newFiber;\r\n      } else {\r\n        WIP.child = newFiber;\r\n        newFiber.oldPoint = null;\r\n      }\r\n      prevFiber = newFiber;\r\n    }\r\n    if (prevFiber) prevFiber.sibling = null;\r\n  }\r\n\r\n  function createFiber (vnode, data) {\r\n    data.tag = isFn(vnode.type) ? HOOK : HOST;\r\n    vnode.props = vnode.props;\r\n    return merge(vnode, data)\r\n  }\r\n\r\n  function completeWork (fiber) {\r\n    if (!options.end && fiber.parent) {\r\n      fiber.parent.patches = (fiber.parent.patches || []).concat(\r\n        fiber.patches || [],\r\n        fiber.patchTag ? [fiber] : []\r\n      );\r\n    } else {\r\n      pendingCommit = fiber;\r\n    }\r\n  }\r\n\r\n  function commitWork (WIP) {\r\n    WIP.patches.forEach(p => commit(p));\r\n    once = false;\r\n    nextWork = null;\r\n    pendingCommit = null;\r\n  }\r\n  function commit (fiber) {\r\n    let p = fiber.parent;\r\n    while (p.tag == HOOK) p = p.parent;\r\n    const parent = p.base;\r\n    let dom = fiber.base || fiber.child.base;\r\n\r\n    switch (fiber.patchTag) {\r\n      case UPDATE:\r\n        updateElement(dom, fiber.alternate.props, fiber.props);\r\n        break\r\n      case DELETE:\r\n        parent.removeChild(dom);\r\n        break\r\n      default:\r\n        const insertPoint = fiber.insertPoint;\r\n        let point = insertPoint ? insertPoint.base : null;\r\n        let after = point ? point.nextSibling : parent.firstChild;\r\n        if (after == dom) return\r\n        if (after === null && dom === parent.lastChild) return\r\n        if (once) after = null;\r\n        parent.insertBefore(dom, after);\r\n        break\r\n    }\r\n    p.patches = [];\r\n    fiber.patches = [];\r\n  }\r\n\r\n  function getWIP () {\r\n    return currentFiber || null\r\n  }\n\n  exports.createContext = createContext;\n  exports.createElement = h;\n  exports.h = h;\n  exports.options = options;\n  exports.render = render;\n  exports.scheduleWork = scheduleWork;\n  exports.useCallback = useCallback;\n  exports.useContext = useContext;\n  exports.useEffect = useEffect;\n  exports.useMemo = useMemo;\n  exports.useReducer = useReducer;\n  exports.useState = useState;\n\n  return exports;\n\n}({}));\n//# sourceMappingURL=fre.js.map\n"]}