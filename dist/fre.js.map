{"version":3,"sources":["dist/fre.js"],"names":["fre","exports","arrayfy","arr","Array","isArray","isSame","a","b","type","isNew","o","n","k","merge","out","i","defer","requestAnimationFrame","setTimeout","h","props","rest","children","length","arguments","push","vnode","pop","nodeValue","key","updateProperty","element","name","value","newValue","style","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","updateElement","newProps","Object","keys","filter","forEach","cursor","useState","initState","useReducer","reducer","current","getWIP","setter","this","state","scheduleWork","bind","useMemo","cb","inputs","hasChaged","oldInputs","some","v","isMounted","options","FPS","HOST","HOOK","ROOT","PLACE","REPLACE","UPDATE","DELETE","updateQueue","nextWork","pendingCommit","currentFiber","fiber","shift","workLoop","startTime","performance","now","nextTime","WIP","tag","reconcileChildren","patches","updateHOOK","end","base","document","createTextNode","createElement","parent","insertPoint","oldPoint","updateHost","child","completeWork","sibling","performWork","commitWork","p","parentFiber","dom","patchTag","alternate","removeChild","after","nextSibling","firstChild","insertBefore","commit","fiberize","item","hashfy","oldFibers","newFibers","reused","newFiber","oldFiber","prevFiber","createFiber","data","concat","createContext","init","set","context","update","subscribe","fn","render","el","useContext","ctx","setContext","useEffect","effect"],"mappings":"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","sourcesContent":["var fre = (function (exports) {\n  'use strict';\n\n  const arrayfy = arr => (!arr ? [] : Array.isArray(arr) ? arr : [arr]);\r\n\r\n  const isSame = (a, b) =>\r\n    a.type === b.type || typeof a.type === typeof b.type;\r\n\r\n  const isNew = (o, n) => k =>\r\n    k !== 'children' && k !== 'key' && o[k] !== n[k];\r\n\r\n  function hashfy (arr) {\r\n    let out = {};\r\n    let i = 0;\r\n    arrayfy(arr).forEach(item => {\r\n      let key = ((item || {}).props || {}).key;\r\n      key ? (out['.' + key] = item) : (out['.' + i] = item) && i++;\r\n    });\r\n    return out\r\n  }\r\n\r\n  function merge (a, b) {\r\n    let out = {};\r\n    for (var i in a) out[i] = a[i];\r\n    for (var i in b) out[i] = b[i];\r\n    return out\r\n  }\r\n  const defer = requestAnimationFrame || setTimeout;\n\n  function h (type, props) {\n    let rest = [];\n    let children = [];\n    let length = arguments.length;\n\n    while (length-- > 2) rest.push(arguments[length]);\n\n    while (rest.length) {\n      let vnode = rest.pop();\n      if (vnode && vnode.pop) {\n        for (length = vnode.length; length--;) rest.push(vnode[length]);\n      } else if (vnode === null || vnode === true || vnode === false) {\n        vnode = { type: () => {} };\n      } else if (typeof vnode === 'function') {\n        children = vnode;\n      } else {\n        children.push(\n          typeof vnode === 'object'\n            ? vnode\n            : { type: 'text', props: { nodeValue: vnode } }\n        );\n      }\n    }\n    return {\n      type,\n      props: merge(props, { children }),\n      key: props && props.key\n    }\n  }\n\n  function updateProperty (element, name, value, newValue) {\n    if (name === 'style') {\n      for (key in newValue) {\n        let style = !newValue || !newValue[key] ? '' : newValue[key];\n        element[name][key] = style;\n      }\n    } else if (name[0] === 'o' && name[1] === 'n') {\n      name = name.slice(2).toLowerCase();\n      if (value) {\n        element.removeEventListener(name, value);\n      }\n      element.addEventListener(name, newValue);\n    } else {\n      element.setAttribute(name, newValue);\n    }\n  }\n\n  function updateElement (element, props, newProps) {\n    Object.keys(newProps)\n      .filter(isNew(props, newProps)) //进行浅比较和过滤\n      .forEach(key => {\n        if (key === 'value' || key === 'nodeValue') {\n          element[key] = newProps[key];\n        } else {\n          updateProperty(element, key, props[key], newProps[key]);\n        }\n      });\n  }\n\n  function createElement (fiber) {\n    const element =\n      fiber.type === 'text'\n        ? document.createTextNode('')\n        : document.createElement(fiber.type);\n    updateElement(element, [], fiber.props);\n    return element\n  }\n\n  let cursor = 0;\n\n  function update(key, reducer, value) {\n    const current = this ? this : getWIP();\n    value = reducer ? reducer(current.state[key], value) : value;\n    current.state[key] = value;\n    scheduleWork(current);\n  }\n  function resetCursor() {\n    cursor = 0;\n  }\n  function useState(initState) {\n    return useReducer(null, initState)\n  }\n  function useReducer(reducer, initState) {\n    let current = getWIP();\n    if (!current) return [initState, setter]\n    let key = '$' + cursor;\n    let setter = update.bind(current, key, reducer);\n    cursor++;\n    let state = current.state || {};\n    if (key in state) {\n      return [state[key], setter]\n    } else {\n      current.state[key] = initState;\n      return [initState, setter]\n    }\n  }\n\n  function useEffect(cb, inputs) {\n    let current = getWIP();\n    if (current) current.effect = useMemo(cb, inputs);\n  }\n\n  function useMemo(cb, inputs) {\n    return () => {\n      let current = getWIP();\n      if (current) {\n        let hasChaged = inputs\n          ? (current.oldInputs || []).some((v, i) => inputs[i] !== v)\n          : true;\n        if (inputs && !inputs.length && !current.isMounted) {\n          hasChaged = true;\n          current.isMounted = true;\n        }\n        if (hasChaged) cb();\n        current.oldInputs = inputs;\n      }\n    }\n  }\n\n  function createContext(init = {}) {\n    let context = init;\n    let set = {};\n    const update = context => {\n      for (let key in set) set[key](context);\n    };\n    const subscribe = (fn, name) => {\n      if(name in set) return\n      set[name] = fn;\n    };\n\n    return { context, update, subscribe, set }\n  }\n\n  function useContext(ctx) {\n    const [context, setContext] = useState(ctx.context);\n    const name = getWIP().type.name;\n    ctx.subscribe(setContext, name);\n    return [context, ctx.update]\n  }\n\n  const options = {};\r\n  const FPS = 1000 / 60;\r\n  const [HOST, HOOK, ROOT, PLACE, REPLACE, UPDATE, DELETE] = [0, 1, 2, 3, 4, 5, 6];\r\n\r\n  let updateQueue = [];\r\n  let nextWork = null;\r\n  let pendingCommit = null;\r\n  let currentFiber = null;\r\n\r\n  function render (vnode, el) {\r\n    let rootFiber = {\r\n      tag: ROOT,\r\n      base: el,\r\n      props: { children: vnode }\r\n    };\r\n    scheduleWork(rootFiber);\r\n  }\r\n\r\n  function scheduleWork (fiber) {\r\n    updateQueue.push(fiber);\r\n    if (!nextWork) {\r\n      nextWork = updateQueue.shift();\r\n      defer(workLoop);\r\n    }\r\n  }\r\n\r\n  function workLoop (startTime = 0) {\r\n    if (startTime && performance.now() - startTime > FPS) {\r\n      defer(workLoop);\r\n    } else {\r\n      const nextTime = performance.now();\r\n      nextWork = performWork(nextWork);\r\n      if (nextWork) {\r\n        workLoop(nextTime);\r\n      } else {\r\n        options.commitWork\r\n          ? options.commitWork(pendingCommit)\r\n          : commitWork(pendingCommit);\r\n      }\r\n    }\r\n  }\r\n\r\n  function performWork (WIP) {\r\n    WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\r\n    if (WIP.child) return WIP.child\r\n    while (WIP) {\r\n      completeWork(WIP);\r\n      if (WIP.sibling) return WIP.sibling\r\n      WIP = WIP.parent;\r\n    }\r\n  }\r\n\r\n  function updateHost (WIP) {\r\n    if (!options.end && !WIP.base) {\r\n      WIP.base = createElement(WIP);\r\n    }\r\n\r\n    let parent = WIP.parent || {};\r\n    WIP.insertPoint = parent.oldPoint;\r\n    parent.oldPoint = WIP;\r\n\r\n    const children = WIP.props.children;\r\n    reconcileChildren(WIP, children);\r\n  }\r\n\r\n  function updateHOOK (WIP) {\r\n    WIP.props = WIP.props || {};\r\n    WIP.state = WIP.state || {};\r\n    currentFiber = WIP;\r\n    resetCursor();\r\n    const children = WIP.type(WIP.props);\r\n    reconcileChildren(WIP, children);\r\n    currentFiber.patches = WIP.patches;\r\n  }\r\n  function fiberize (children, WIP) {\r\n    return (WIP.children = hashfy(children))\r\n  }\r\n\r\n  function reconcileChildren (WIP, children) {\r\n    const oldFibers = WIP.children;\r\n    const newFibers = fiberize(children, WIP);\r\n    let reused = {};\r\n\r\n    for (let k in oldFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = oldFibers[k];\r\n      if (newFiber && isSame(newFiber, oldFiber)) {\r\n        reused[k] = oldFiber;\r\n      } else {\r\n        oldFiber.patchTag = DELETE;\r\n        WIP.patches.push(oldFiber);\r\n      }\r\n    }\r\n\r\n    let prevFiber = null;\r\n    let alternate = null;\r\n\r\n    for (let k in newFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = reused[k];\r\n\r\n      if (oldFiber) {\r\n        if (isSame(oldFiber, newFiber)) {\r\n          alternate = createFiber(oldFiber, {\r\n            patchTag: UPDATE\r\n          });\r\n\r\n          if (!options.end) newFiber.patchTag = UPDATE;\r\n          newFiber = merge(alternate, newFiber);\r\n          newFiber.alternate = alternate;\r\n          if (oldFiber.key) {\r\n            newFiber.patchTag = REPLACE;\r\n          }\r\n        }\r\n      } else {\r\n        newFiber = createFiber(newFiber, {\r\n          patchTag: PLACE\r\n        });\r\n      }\r\n      newFibers[k] = newFiber;\r\n      newFiber.parent = WIP;\r\n\r\n      if (prevFiber) {\r\n        prevFiber.sibling = newFiber;\r\n      } else {\r\n        WIP.child = newFiber;\r\n      }\r\n      prevFiber = newFiber;\r\n    }\r\n    if (prevFiber) prevFiber.sibling = null;\r\n  }\r\n\r\n  function createFiber (vnode, data) {\r\n    data.tag = typeof vnode.type === 'function' ? HOOK : HOST;\r\n    vnode.props = vnode.props || { nodeValue: vnode.nodeValue };\r\n    return merge(vnode, data)\r\n  }\r\n\r\n  function completeWork (fiber) {\r\n    if (!options.end && fiber.parent) {\r\n      fiber.parent.patches = (fiber.parent.patches || []).concat(\r\n        fiber.patches || [],\r\n        fiber.patchTag ? [fiber] : []\r\n      );\r\n    } else {\r\n      pendingCommit = fiber;\r\n    }\r\n  }\r\n\r\n  function commitWork (WIP) {\r\n    WIP.patches.forEach(p => commit(p));\r\n    nextWork = pendingCommit = null;\r\n  }\r\n\r\n  function commit (fiber) {\r\n    let parentFiber = fiber.parent;\r\n    while (parentFiber.tag == HOOK) {\r\n      parentFiber = parentFiber.parent;\r\n    }\r\n    const parent = parentFiber.base;\r\n    let dom = fiber.base || fiber.child.base;\r\n    const { insertPoint, patchTag } = fiber;\r\n    if (fiber.parent.tag == ROOT) ; else if (patchTag == UPDATE) {\r\n      updateElement(dom, fiber.alternate.props, fiber.props);\r\n    } else if (patchTag == DELETE) {\r\n      parent.removeChild(dom);\r\n    } else {\r\n      let after = insertPoint\r\n        ? patchTag == PLACE\r\n          ? insertPoint.base.nextSibling\r\n          : insertPoint.base.nextSibling || parent.firstChild\r\n        : null;\r\n      if (after == dom) return\r\n      parent.insertBefore(dom, after);\r\n    }\r\n    parentFiber.patches = fiber.patches = [];\r\n  }\r\n\r\n  function getWIP () {\r\n    return currentFiber || null\r\n  }\n\n  exports.createContext = createContext;\n  exports.createElement = h;\n  exports.h = h;\n  exports.options = options;\n  exports.render = render;\n  exports.scheduleWork = scheduleWork;\n  exports.useContext = useContext;\n  exports.useEffect = useEffect;\n  exports.useMemo = useMemo;\n  exports.useReducer = useReducer;\n  exports.useState = useState;\n\n  return exports;\n\n}({}));\n//# sourceMappingURL=fre.js.map\n"]}