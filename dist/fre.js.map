{"version":3,"sources":["dist/fre.js"],"names":["fre","exports","arrayfy","arr","Array","isArray","isSame","a","b","type","isNew","o","n","k","merge","out","i","defer","requestAnimationFrame","setTimeout","isFn","fn","h","props","rest","children","length","arguments","push","vnode","pop","nodeValue","key","updateProperty","element","name","value","newValue","style","slice","toLowerCase","removeEventListener","addEventListener","setAttribute","updateElement","newProps","Object","keys","filter","forEach","cursor","useState","initState","useReducer","reducer","current","getWIP","setter","this","state","scheduleWork","bind","useCallback","cb","inputs","useMemo","hasChaged","oldInputs","some","v","isMounted","options","FPS","HOST","HOOK","ROOT","PLACE","REPLACE","UPDATE","DELETE","updateQueue","nextWork","pendingCommit","currentFiber","fiber","shift","workLoop","startTime","performance","now","nextTime","WIP","tag","reconcileChildren","patches","updateHOOK","end","base","document","createTextNode","createElement","parent","insertPoint","oldPoint","updateHost","child","completeWork","sibling","performWork","commitWork","p","dom","patchTag","alternate","removeChild","after","nextSibling","firstChild","insertBefore","commit","fiberize","item","hashfy","oldFibers","newFibers","reused","newFiber","oldFiber","prevFiber","createFiber","data","concat","createContext","init","set","context","update","subscribe","render","el","useContext","ctx","setContext","useEffect","effect"],"mappings":"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","sourcesContent":["var fre = (function (exports) {\n  'use strict';\n\n  const arrayfy = arr => (!arr ? [] : Array.isArray(arr) ? arr : [arr]);\r\n\r\n  const isSame = (a, b) => a.type === b.type;\r\n\r\n  const isNew = (o, n) => k =>\r\n    k !== 'children' && k !== 'key' && o[k] !== n[k];\r\n\r\n  function hashfy (arr) {\r\n    let out = {};\r\n    let i = 0;\r\n    arrayfy(arr).forEach(item => {\r\n      let key = ((item || {}).props || {}).key;\r\n      key ? (out['.' + key] = item) : (out['.' + i] = item) && i++;\r\n    });\r\n    return out\r\n  }\r\n\r\n  function merge (a, b) {\r\n    let out = {};\r\n    for (const i in a) out[i] = a[i];\r\n    for (const i in b) out[i] = b[i];\r\n    return out\r\n  }\r\n  const defer = requestAnimationFrame || setTimeout;\r\n\r\n  const isFn = fn => typeof fn === 'function';\n\n  function h (type, props) {\n    let rest = [];\n    let children = [];\n    let length = arguments.length;\n\n    while (length-- > 2) rest.push(arguments[length]);\n\n    while (rest.length) {\n      let vnode = rest.pop();\n      if (vnode && vnode.pop) {\n        for (length = vnode.length; length--;) rest.push(vnode[length]);\n      } else if (vnode === null || vnode === true || vnode === false) {\n        vnode = { type: () => {} };\n      } else if (typeof vnode === 'function') {\n        children = vnode;\n      } else {\n        children.push(\n          typeof vnode === 'object'\n            ? vnode\n            : { type: 'text', props: { nodeValue: vnode } }\n        );\n      }\n    }\n    return {\n      type,\n      props: merge(props, { children }),\n      key: props && props.key\n    }\n  }\n\n  function updateProperty (element, name, value, newValue) {\n    if (name === 'style') {\n      for (key in newValue) {\n        let style = !newValue || !newValue[key] ? '' : newValue[key];\n        element[name][key] = style;\n      }\n    } else if (name[0] === 'o' && name[1] === 'n') {\n      name = name.slice(2).toLowerCase();\n      if (value) {\n        element.removeEventListener(name, value);\n      }\n      element.addEventListener(name, newValue);\n    } else {\n      element.setAttribute(name, newValue);\n    }\n  }\n\n  function updateElement (element, props, newProps) {\n    Object.keys(newProps)\n      .filter(isNew(props, newProps)) //进行浅比较和过滤\n      .forEach(key => {\n        if (key === 'value' || key === 'nodeValue') {\n          element[key] = newProps[key];\n        } else {\n          updateProperty(element, key, props[key], newProps[key]);\n        }\n      });\n  }\n\n  function createElement (fiber) {\n    const element =\n      fiber.type === 'text'\n        ? document.createTextNode('')\n        : document.createElement(fiber.type);\n    updateElement(element, [], fiber.props);\n    return element\n  }\n\n  let cursor = 0;\n\n  function update (key, reducer, value) {\n    const current = this ? this : getWIP();\n    value = reducer ? reducer(current.state[key], value) : value;\n    current.state[key] = value;\n    scheduleWork(current);\n  }\n  function resetCursor () {\n    cursor = 0;\n  }\n  function useState (initState) {\n    return useReducer(null, initState)\n  }\n  function useReducer (reducer, initState) {\n    let current = getWIP();\n    if (!current) return [initState, setter]\n    let key = '$' + cursor;\n    let setter = update.bind(current, key, reducer);\n    cursor++;\n    let state = current.state || {};\n    if (key in state) {\n      return [state[key], setter]\n    } else {\n      current.state[key] = initState;\n      return [initState, setter]\n    }\n  }\n\n  function useEffect (cb, inputs) {\n    let current = getWIP();\n    if (current) current.effect = useCallback(cb, inputs);\n  }\n\n  function useCallback (cb, inputs) {\n    return useMemo(() => cb, inputs)\n  }\n\n  function useMemo (cb, inputs) {\n    let current = getWIP();\n    if (current) {\n      let hasChaged = inputs\n        ? (current.oldInputs || []).some((v, i) => inputs[i] !== v)\n        : true;\n      if (inputs && !inputs.length && !current.isMounted) {\n        hasChaged = true;\n        current.isMounted = true;\n      }\n      current.oldInputs = inputs;\n      \n      if (hasChaged) return cb()\n    }\n  }\n\n  function createContext (init = {}) {\n    let context = init;\n    let set = {};\n    const update = context => {\n      for (let key in set) set[key](context);\n    };\n    const subscribe = (fn, name) => {\n      if (name in set) return\n      set[name] = fn;\n    };\n\n    return { context, update, subscribe, set }\n  }\n\n  function useContext (ctx) {\n    const [context, setContext] = useState(ctx.context);\n    const name = getWIP().type.name;\n    ctx.subscribe(setContext, name);\n    return [context, ctx.update]\n  }\n\n  const options = {};\r\n  const FPS = 1000 / 60;\r\n  const [HOST, HOOK, ROOT, PLACE, REPLACE, UPDATE, DELETE] = [0, 1, 2, 3, 4, 5, 6];\r\n\r\n  let updateQueue = [];\r\n  let nextWork = null;\r\n  let pendingCommit = null;\r\n  let currentFiber = null;\r\n\r\n  function render (vnode, el) {\r\n    let rootFiber = {\r\n      tag: ROOT,\r\n      base: el,\r\n      props: { children: vnode }\r\n    };\r\n    scheduleWork(rootFiber);\r\n  }\r\n\r\n  function scheduleWork (fiber) {\r\n    updateQueue.push(fiber);\r\n    if (!nextWork) {\r\n      nextWork = updateQueue.shift();\r\n      defer(workLoop);\r\n    }\r\n  }\r\n\r\n  function workLoop (startTime = 0) {\r\n    if (startTime && performance.now() - startTime > FPS) {\r\n      defer(workLoop);\r\n    } else {\r\n      const nextTime = performance.now();\r\n      nextWork = performWork(nextWork);\r\n      if (nextWork) {\r\n        workLoop(nextTime);\r\n      } else {\r\n        options.commitWork\r\n          ? options.commitWork(pendingCommit)\r\n          : commitWork(pendingCommit);\r\n      }\r\n    }\r\n  }\r\n\r\n  function performWork (WIP) {\r\n    WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\r\n    if (WIP.child) return WIP.child\r\n    while (WIP) {\r\n      completeWork(WIP);\r\n      if (WIP.sibling) return WIP.sibling\r\n      WIP = WIP.parent;\r\n    }\r\n  }\r\n\r\n  function updateHost (WIP) {\r\n    if (!options.end && !WIP.base) {\r\n      WIP.base = createElement(WIP);\r\n    }\r\n\r\n    let parent = WIP.parent || {};\r\n    WIP.insertPoint = parent.oldPoint;\r\n    parent.oldPoint = WIP;\r\n\r\n    const children = WIP.props.children;\r\n    reconcileChildren(WIP, children);\r\n  }\r\n\r\n  function updateHOOK (WIP) {\r\n    WIP.props = WIP.props || {};\r\n    WIP.state = WIP.state || {};\r\n    currentFiber = WIP;\r\n    resetCursor();\r\n    const children = WIP.type(WIP.props);\r\n    reconcileChildren(WIP, children);\r\n    currentFiber.patches = WIP.patches;\r\n  }\r\n  function fiberize (children, WIP) {\r\n    return (WIP.children = hashfy(children))\r\n  }\r\n\r\n  function reconcileChildren (WIP, children) {\r\n    const oldFibers = WIP.children;\r\n    const newFibers = fiberize(children, WIP);\r\n    let reused = {};\r\n\r\n    for (let k in oldFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = oldFibers[k];\r\n      if (newFiber && isSame(newFiber, oldFiber)) {\r\n        reused[k] = oldFiber;\r\n      } else {\r\n        oldFiber.patchTag = DELETE;\r\n        WIP.patches.push(oldFiber);\r\n      }\r\n    }\r\n\r\n    let prevFiber = null;\r\n    let alternate = null;\r\n\r\n    for (let k in newFibers) {\r\n      let newFiber = newFibers[k];\r\n      let oldFiber = reused[k];\r\n\r\n      if (oldFiber) {\r\n        if (isSame(oldFiber, newFiber)) {\r\n          alternate = createFiber(oldFiber, {\r\n            patchTag: UPDATE\r\n          });\r\n          if (!options.end) newFiber.patchTag = UPDATE;\r\n          newFiber = merge(alternate, newFiber);\r\n          newFiber.alternate = alternate;\r\n          if (oldFiber.key) {\r\n            newFiber.patchTag = REPLACE;\r\n          }\r\n        } else {\r\n          oldFiber.patchTag = DELETE;\r\n          WIP.patches.push(oldFiber);\r\n        }\r\n      } else {\r\n        newFiber = createFiber(newFiber, {\r\n          patchTag: PLACE\r\n        });\r\n      }\r\n      newFibers[k] = newFiber;\r\n      newFiber.parent = WIP;\r\n\r\n      if (prevFiber) {\r\n        prevFiber.sibling = newFiber;\r\n      } else {\r\n        WIP.child = newFiber;\r\n      }\r\n      prevFiber = newFiber;\r\n    }\r\n    if (prevFiber) prevFiber.sibling = null;\r\n  }\r\n\r\n  function createFiber (vnode, data) {\r\n    data.tag = isFn(vnode.type) ? HOOK : HOST;\r\n    vnode.props = vnode.props || { nodeValue: vnode.nodeValue };\r\n    return merge(vnode, data)\r\n  }\r\n\r\n  function completeWork (fiber) {\r\n    if (!options.end && fiber.parent) {\r\n      fiber.parent.patches = (fiber.parent.patches || []).concat(\r\n        fiber.patches || [],\r\n        fiber.patchTag ? [fiber] : []\r\n      );\r\n    } else {\r\n      pendingCommit = fiber;\r\n    }\r\n  }\r\n\r\n  function commitWork (WIP) {\r\n    WIP.patches.forEach(p => commit(p));\r\n    nextWork = null;\r\n    pendingCommit = null;\r\n  }\r\n\r\n  function commit (fiber) {\r\n    let p = fiber.parent;\r\n    while (p.tag == HOOK) p = p.parent;\r\n\r\n    const parent = p.base;\r\n    let dom = fiber.base || fiber.child.base;\r\n\r\n    const { insertPoint, patchTag } = fiber;\r\n    if (fiber.parent.tag === ROOT) ; else if (patchTag == UPDATE) {\r\n      updateElement(dom, fiber.alternate.props, fiber.props);\r\n    } else if (patchTag == DELETE) {\r\n      parent.removeChild(dom);\r\n    } else {\r\n      let after = insertPoint\r\n        ? insertPoint.base.nextSibling || parent.firstChild\r\n        : null;\r\n      if (after == dom) return\r\n      if (patchTag == PLACE) after = null;\r\n      parent.insertBefore(dom, after);\r\n    }\r\n    p.patches = [];\r\n    fiber.patches = [];\r\n  }\r\n\r\n  function getWIP () {\r\n    return currentFiber || null\r\n  }\n\n  exports.createContext = createContext;\n  exports.createElement = h;\n  exports.h = h;\n  exports.options = options;\n  exports.render = render;\n  exports.scheduleWork = scheduleWork;\n  exports.useCallback = useCallback;\n  exports.useContext = useContext;\n  exports.useEffect = useEffect;\n  exports.useMemo = useMemo;\n  exports.useReducer = useReducer;\n  exports.useState = useState;\n\n  return exports;\n\n}({}));\n//# sourceMappingURL=fre.js.map\n"]}